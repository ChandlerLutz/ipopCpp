# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Solve Quadratic Programming problems
#'
#' Adopted from the kernlab::ipop() R function
#'
#' ipop solves the quadratic programming problem
#' minimize   \code{c\' * primal + 1/2 primal\' * H * primal}
#' subject to \code{b <= A*primal <= b + r}
#'            \code{l <= x <= u}
#'            d is the optimizer itself
#' returns primal and dual variables (i.e. x and the Lagrange
#' multipliers for b <= A * primal <= b + r)
#' for additional documentation see
#'      R. Vanderbei
#'      LOQO: an Interior Point Code for Quadratic Programming, 1992
#' Author:  R version Alexandros Karatzoglou, orig. matlab Alex J. Smola
#'
#' @title Quadratic Optimization Solver
#' @param c Vector or one column matrix appearing in the quadratic function
#' @param H square matrix appearing in the quadratic function, or the
#' decomposed form \code{Z} of the \code{H} matrix where \code{Z} is a
#' \code{n x m} matrix with \code{n > m} and \code{ZZ\' = H}.
#' @param A Matrix defining the constrains under which we minimize the
#' quadratic function
#' @param b Vector or one column matrix defining the constraints
#' @param l Lower bound vector or one column matrix
#' @param u Upper bound vector or one column matrix
#' @param r Upper bound vector or one column matrix
#' @param sigf Precision (default: 7 significant figures)
#' @param maxiter Maximum number of iterations
#' @param margin how close we get to the constrains
#' @param bound Clipping bound for the variables
#' @return A list with the output with the "primal" solution, the "dual"
#' solution, and convergence information
#' @author Chandler Lutz
#' @examples
#' ##Comparison to kernlab::ipop()
#' library(kernlab)
#' ## solve the Support Vector Machine optimization problem
#' data(spam)
#' ## sample a scaled part (500 points) of the spam data set
#' m <- 500
#' set <- sample(1:dim(spam)[1],m)
#' x <- scale(as.matrix(spam[,-58]))[set,]
#' y <- as.integer(spam[set,58])
#' y[y==2] <- -1
#' ##set C parameter and kernel
#' C <- 5
#' rbf <- rbfdot(sigma = 0.1)
#' ## create H matrix etc.
#' H <- kernelPol(rbf,x,,y)
#' c <- matrix(rep(-1,m))
#' A <- t(y)
#' b <- matrix(0)
#' l <- matrix(rep(0,m))
#' u <- matrix(rep(C,m))
#' r <- matrix(0)
#' sv <- ipop(c,H,A,b,l,u,r)
#' sv2 <- ipopCpp(c,H,A,b,l,u,r)
#' all.equal(ipop(c,H,A,b,l,u,r)@primal, as.numeric(ipopCpp(c,H,A,b,l,u,r)$primal))
#' all.equal(ipop(c,H,A,b,l,u,r)@dual, as.numeric(ipopCpp(c,H,A,b,l,u,r)$dual))
#'
ipopCpp <- function(c, H, A, b, l, u, r, sigf = 7L, maxiter = 40L, margin = 0.05, bound = 10) {
    .Call('ipopCpp_ipopCpp', PACKAGE = 'ipopCpp', c, H, A, b, l, u, r, sigf, maxiter, margin, bound)
}

