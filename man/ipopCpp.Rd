% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{ipopCpp}
\alias{ipopCpp}
\title{Quadratic Optimization Solver}
\usage{
ipopCpp(c, H, A, b, l, u, r, sigf = 7L, maxiter = 40L, margin = 0.05,
  bound = 10)
}
\arguments{
\item{c}{Vector or one column matrix appearing in the quadratic function}

\item{H}{square matrix appearing in the quadratic function, or the
decomposed form \code{Z} of the \code{H} matrix where \code{Z} is a
\code{n x m} matrix with \code{n > m} and \code{ZZ\' = H}.}

\item{A}{Matrix defining the constrains under which we minimize the
quadratic function}

\item{b}{Vector or one column matrix defining the constraints}

\item{l}{Lower bound vector or one column matrix}

\item{u}{Upper bound vector or one column matrix}

\item{r}{Upper bound vector or one column matrix}

\item{sigf}{Precision (default: 7 significant figures)}

\item{maxiter}{Maximum number of iterations}

\item{margin}{how close we get to the constrains}

\item{bound}{Clipping bound for the variables}
}
\value{
A list with the output with the "primal" solution, the "dual"
solution, and convergence information
}
\description{
Solve Quadratic Programming problems
}
\details{
Adopted from the kernlab::ipop() R function

ipop solves the quadratic programming problem
minimize   \code{c\' * primal + 1/2 primal\' * H * primal}
subject to \code{b <= A*primal <= b + r}
           \code{l <= x <= u}
           d is the optimizer itself
returns primal and dual variables (i.e. x and the Lagrange
multipliers for b <= A * primal <= b + r)
for additional documentation see
     R. Vanderbei
     LOQO: an Interior Point Code for Quadratic Programming, 1992
Author:  R version Alexandros Karatzoglou, orig. matlab Alex J. Smola
}
\examples{
##Comparison to kernlab::ipop()
library(kernlab)
## solve the Support Vector Machine optimization problem
data(spam)
## sample a scaled part (500 points) of the spam data set
m <- 500
set <- sample(1:dim(spam)[1],m)
x <- scale(as.matrix(spam[,-58]))[set,]
y <- as.integer(spam[set,58])
y[y==2] <- -1
##set C parameter and kernel
C <- 5
rbf <- rbfdot(sigma = 0.1)
## create H matrix etc.
H <- kernelPol(rbf,x,,y)
c <- matrix(rep(-1,m))
A <- t(y)
b <- matrix(0)
l <- matrix(rep(0,m))
u <- matrix(rep(C,m))
r <- matrix(0)
sv <- ipop(c,H,A,b,l,u,r)
sv2 <- ipopCpp(c,H,A,b,l,u,r)
all.equal(ipop(c,H,A,b,l,u,r)@primal, as.numeric(ipopCpp(c,H,A,b,l,u,r)$primal))
all.equal(ipop(c,H,A,b,l,u,r)@dual, as.numeric(ipopCpp(c,H,A,b,l,u,r)$dual))

}
\author{
Chandler Lutz
}

